# Using the Local Database with Rhom

Rhom is a mini database object mapper for Rhodes. It provides a high level interface to make it very powerful and simple to use a local database.  That database is SQLite on all platforms except BlackBerry where it is HSQLDB.

Rhom currently supports two model types: ***Property Bag (default)*** and ***Fixed Schema***

## Property Bag
With a property bag model, all is stored in a single table using the object-attribute-value pattern also referred to as the [Entity-attribute-value model](http://en.wikipedia.org/wiki/Entity-attribute-value_model).

### Property Bag Advantages
* Simple to use, it doesn't require specifying attributes.
* Data migrations are not necessary.
* Attributes can be added or removed without modifying the database schema.

### Property Bag Disadvantages
* For some applications, the database size may be up to three times larger than fixed schema.  This is because each attribute is indexed for fast lookup.
* Sync process may be slightly slower because inserts are performed at attribute level.

In a property bag model, Rhom groups objects by their source id and object id.  The following example illustrates this idea:

<pre>
Source ID: 1, Model Name: Account
+-----------+----------+--------------+----------------------+
| source_id | attrib   | object       | value                |
+-----------+----------+--------------+------- --------------+
|         1 | name     | 48f39f63741b | A.G. Parr PLC 37862  | 
|         1 | industry | 48f39f63741b | Entertainment        |
|         1 | name     | 48f39f230529 | Jones Group          |
|         1 | industry | 48f39f230529 | Sales                |
+-----------+----------+--------------+----------------------+
</pre>

Here, Rhom will expose a class `Account` with two attributes: `name` and `industry`

	:::ruby
	account = Account.find('48f39f63741b')
	account.name
	  #=> "A.G. Parr PLC 37862"
	
	account.industry
	  #=> "Entertainment"
	
### Using Property Bag Models
To use a property bag model, simply generate a new model with some attributes:

	:::term
	$ rhodes model product name,brand,price,quantity,sku
	
This will generate a file called `product.rb` which looks like:

	:::ruby
	class Product
	  include Rhom::PropertyBag

	  # Uncomment the following line to enable sync with Product.
	  # enable :sync

	  #add model specifc code here
	end
	
There are several features you can enable or disable in the model, below is a complete list:

	:::ruby
	class SomeModel
	  include Rhom::PropertyBag

	  # rhosync settings
	  # Enable sync for this model.
	  # Default is disabled.
	  enable :sync 

	  # Set the type of sync this model
	  # will use (default :incrmental).
	  # Set to :bulk_only to disable incremental
	  # sync and only use bulk sync.
	  set :sync_type, :bulk_only 
	
	  # Set the sync priority for this model.
	  # 1000 is default, set to lower number
	  # for a higher priority.
	  set :sync_priority, 1     

	  # Instruct Rhom to send all attributes
	  # to RhoSync when an object is updated.
	  # Default is disabled, only changed attributes
	  # are sent.
	  enable :full_update 
	
	
	  # model settings
	
	  # Define how data is partitioned for this model.
      # Default is :user.  If you have an :app partition
	  # for your RhoSync source adapter and use bulk sync,
	  # set this to :app also.
	  set :partition, :app

	  # Define blob attributes for the model.
	  # :blob			Declare property as a blob type
	  #
	  # :overwrite		(optional) Overwrite client copy 
	  #					of blob with new copy from server.
	  #                 This is useful when RhoSync modifies
	  # 				images sent from Rhodes, for example 
	  #					zooming or cropping.
	  property :image_url, :blob, :overwrite 
	
	  # You can define your own properties also
	  property :mycustomproperty, 'hello'
	end

## Fixed Schema

### Property Bag Advantages
* Smaller database size, indexes can be specified only on specific attributes.
* Sync process may perform faster because whole objects are inserted at a time.

### Property Bag Disadvantages
* Schema changes must be handled with data migrations.
* Database performance may be slow unless you specify proper indexes.

### Using Fixed Schema Models

	:::ruby
	class SomeModel
	  include Rhom::FixedSchema

	  # rhosync settings
	  enable :sync #default is disabled - for local models
	                    # you may use set :sync, true instead
	  set :sync_type, :bulk_only #default is :incremental (which allow for bulk and regular sync)
	  set :sync_priority, 1     #1000 by default, first will sync models with 0, then 1 etc

	  enable :full_update #send all attributes from client when call update server method - not only changed ones

	  # model settings
	  # if you use other than user partition, partition name should correspond with ones from settings.yml from the server app
	  set :partition, :app # optional, default :user

	  set :schema_version, '1.0' #application may use it for data migration

	  # object properties 
	  property :name, :string
	  property :tag, :string
	  property :phone, :string
	  property :image_url, :blob

	  # blob fields called out explicitly to identify field type
	  # :blob - declare property as a blob type
	  # :overwrite - (optional) overwrite client copy of blob with new copy from server
	  #                    useful when server modifies images, for example zooming or cropping
	  property :cropped_image_url, :blob, :overwrite


	  # object column will be added by rhom and  will be primary key

	  #indexes
	  index :by_name_tag, [:name, :tag] #will create index for name and tag columns

	  unique_index :by_phone, [:phone] #will create unique index for phone column
	end

### Data migration
On the first application start after application was first time installed or updated/reloaded database will be (re)created if `app_db_version` in the `rhoconfig.txt` is different from what it was before. If db version is changed and db is recreated then all data in the db is erased and will be lost.
Note: since Rhodes 2.2.4 Rhosync session is kept in database, so SyncEngine.logged_in will return true. At start application can check that db is empty but user still logge in and run sync without interactive login

Application db version in `rhoconfig.txt`:
	
	app_db_version = '1.0'

When you use Fixed Schema model application developer is responsible for sql schema. So when you add or delete some properties or just change app logic you may need to perform data migration or database reset. To track schema changes use schema_version parameter in the model:

	:::ruby
	class Product
	  include Rhom::FixedSchema

	  set :schema_version, '1.1'
	end

	:::ruby
	class AppApplication < Rho::RhoApplication
	  # this method called when schema_version parameter has been changed in 2 cases:
	  # at application start
	  # when server send sources to client
	  # old_version is String containing old version value
	  # new_src is Hash with source parameters like 'schema_version', 'name' etc; new_src['schema']['sql'] contain sql table creation script
	  def on_migrate_source(old_version, new_src)
	    # call super to delete table
	    # return false to run sql script to create table with new schema 
	  end
	end

	
## Rhom API
Below is the full list of methods available to Rhom models:

### `clear_notification`
Used to clear the notification for the object, see the [sync notification section](/rhodes/sync-engine#notify) for more details.

### `delete_all(conditions)`
Deletes all rhom objects for a source, optionally filtering by conditions:

	:::ruby
	# :conditions 	Delete only objects matching these criteria. 
	#               Supports find() conditions.
	# :op  			See advanced find syntax
	Account.delete_all(:conditions => {'industry'=>'electronics'})

### `destroy`
Delete a rhom object.

	:::ruby
	@account = Account.find(:all).first
	@account.destroy

### `find(*args)`
Returns rhom object(s) based on the following arguments:

	:::ruby
	# :all 			returns all objects w/ optional conditions
	#
	# :first		returns first object matching conditions
	#
	# :count 		returns number of objects matching conditions
	#
	# :conditions 	(optional) hash of attribute/values to match
	# 				supports sql fragment(i.e. "name like 'rhomobile') 
	#				or sql fragment with binding 
	#				(i.e. ["name like ?", "'#{company#}'"])
	# 				Note: use single comma around string values 
	#
	# :order 		(optional) attribute(s) to order the list
	#
	# :orderdir 	(optional) order direction('ASC' (default), 'DESC' )
	#
	# :select 		(optional) array of string attributes to return 
	#				with the object.  This is useful if your model 
	#				has a lot of attributes but your query only needs 
	#				a few of them.
	#
	# :per_page 	(optional) maximum number of items return 
	#
	# :offset 		(optional) offset from beginning of the list

	acct = Account.find "3560c0a0-ef58-2f40-68a5-48f39f63741b"
	
	acct.name 
	  #=> "A.G. Parr PLC 37862"

	accts = Account.find(:all, :select => ['name','address'])
	
	accts[0].name 
	  #=> "A.G. Parr PLC 37862"
	
	accts[0].telephone 
	  #=> nil

**NOTE: Use SQL fragments with caution.  They are considerably slower than advanced queries [described below](/rhodes/rhom#advanced-queries).**

#### Order Examples
The `:order` argument accepts several forms:

* `:order` by one attribute:

  		:::ruby
		@accts = Account.find(
		  :all, 
		  :order => 'name',
		  :orderdir => 'DESC'
		)

* `:order` by one attribute with block:

    	:::ruby
		@accts = Account.find(:all, :order => 'name') do |x,y|
	      y <=> x    
	    end

* `:order` with block:

    	:::ruby
		@accts = Account.find(:all) do |item1,item2|
	      item2.name <=> item1.name
	    end

* `:order` by multiple attributes

    	:::ruby
		@accts = Account.find(
		  :all, 
	      :order => ['name', 'industry'], 
	      :orderdir => ['ASC', 'DESC']
 		)

### `find_all(*args)`
Alias for find(:all,*args).

### `new(attributes = nil)`
Creates a new rhom object and assigns given attributes, or initializes an empty rhom object.

	:::ruby
	@account = Account.new(
	  {"name" => "ABC Inc.","address" => "555 5th St."}
	)
	@account.name 
	  #=> "ABC Inc."

### `save`
Saves the current rhom object to the database.

	:::ruby
	@account = Account.new(
	  {"name" => "some new record", "industry" => "electronics"}
	)
	@account.save

### `create(attributes)`
Creates a new rhom object and saves to the database. 

**NOTE: This is the fastest way to insert a single item into the database.**

	:::ruby
	@account = Account.create(
	  {"name" => "some new record", "industry" => "electronics"}
	)

### `paginate(*args)`
Calls `find` with a limit on the # of records.  This emulates rails' classic pagination syntax. Default page size is 10.

	:::ruby
	# :page 		which page to return, used as offset 
	#				in combination with :per_page
	#				
	# :per_page 	number of records to return (used as limit)
	#
	# :conditions 	same as find with :conditions
	#
	# :order 		same as find with :order
	#
	# :select 		same as find with :select
	
	Account.paginate(:page => 0) 
	  #=> returns first 10 records
	Account.paginate(:page => 1, :per_page => 20) 
	  #=> returns records 21-40
	Account.paginate(
	  :page => 5, 
	  :conditions => {'industry' => 'Technology'}, 
	  :order => 'name'
	) #=> you can have :conditions and :order as well

### `sync(callback = nil, callback_data = "", show_status_popup = nil)`
Start the sync process for a model. If the callback is set, `SyncEngine.set_notification` is called before `SyncEngine.dosync`.
	
	:::ruby
	Account.sync( url_for(:action => :sync_callback) )

### `set_notification(url)`
Used to asynchronously refresh the page, see [[RhodesConnectToWebServices#Sync_notification|Sync Notification Docs]] for more details.

### `update_attributes(attributes)`
Updates the current rhom object's attributes and saves it to the database

	:::ruby
	@account = Account.find(
	  :all, 
	  :conditions=>{'name' => 'ABC Inc.'}
	)
	@account.update_attributes(
	  {"name" => "ABC Inc.", "industry" => "Technology"}
	)
	@account.industry   
	  #=> "Technology"

### `can_modify`
Before displaying an edit page for an object, your application can check if the object is currently being accessed by the sync process.  If it is, you should disable editing of the object.  `can_modify` could return true, for example, on a new local record that was created and sent to the RhoSync application, but no response has been received yet.

	:::ruby
  	def edit
	  @product = Product.find(@params['id'])
	  if @product && !@product.can_modify
	    render :action => :show_edit_error
	  else    
	    render :action => :edit
	  end
	end

### `changed?`
Determine if a rhom model has local database changes that need to be synchronized.

       :::ruby
       def should_sync_product_object
         if Product.changed?
           #... do stuff ...
         end
       end

## Associations
<source lang='ruby'>
class Customer
  include Rhom::PropertyBag

  belongs_to :product_id, 'Product'

  #Rhodes 2.2 support polymorphic relationships:
  belongs_to :parent_id, ['Product', 'Cases']
  #or
  belongs_to :parent_id, 'Product'
  belongs_to :parent_id, 'Cases'

end

#product_controller.rb create code:
def create
  @product = Product.new(@params['product'])
  @product.save

  cust = Customer.find(:first) #find customer
  cust.product_id = @product.object
  cust.save
  redirect :action => :index
end
</source>
After sync object id of new Product will be updated in product_id
NOTE(rhodes < 2.0.4): to work correct in this scenario Product should sync before Customer, so if Customer has sync priority=1, Product should has 0. Rhodes > 2.0.4 reorder sources automatically


## Accessing Sync Info with RhomSource
Rhodes sync sources are also available by the Rhodes Ruby framework through the RhomSource object.  
You can use RhomSource just like a normal Rhom object with the exception that only the source_url field is writeable (below is the SourceController provided in the sample applications which demonstrates how to use RhomSource):

You can also access the following attributes on RhomSource:

<source lang='ruby'>
@source = RhomSource.find(@params['id'])
puts @source.source_id #id of source
puts @source.name #name of source
puts @source.source_url #url of a source
puts @source.last_updated #returns Time object of last sync for the source (in Time.at format)
puts @source.last_inserted_size #returns number of records inserted on last sync
puts @source.last_deleted_size #returns number of records deleted on last sync
puts @source.last_sync_duration #returns duration of last sync for this source in seconds
puts @source.last_sync_success #returns 1 if sync was successful, 0 otherwise
puts @source.distinct_object #returns number of records
</source>

Show last sync time for Product source example:
<source lang='ruby'>
<%= ::Rhom::RhomSource.find(Product.get_source_id).last_updated.strftime("%m/%d/%Y, %I:%M%p") %>
</source>

## Resetting the Database
Rhodes provides the following functions for recovering the database from a bad or corrupt state, or if the RhoSync server returns errors.

### `Rhom::Rhom.database_full_reset(reset_client_info=false, reset_local_models=true)` 
Deletes all records from the property bag and model tables.
	
	:::ruby
	# reset_client_info 	If set to true, client_info 
	#						table will be cleaned.
	#
	# reset_local_models 	If set to true, local(non-synced models) 
	#						will be cleaned.
	Rhom::Rhom.database_full_reset(false,true)
	
### `Rhom::Rhom.database_full_reset_and_logout` 
Perform a full reset and then logout the RhoSync client.

	:::ruby
	Rhom::Rhom.database_full_reset_and_logout

### `Rhom::Rhom.database_fullclient_reset_and_logout` 
Equivalent to `Rhom::Rhom.database_full_reset(true)` followed by `SyncEngine.logout`.

	:::ruby
	Rhom::Rhom.database_fullclient_reset_and_logout
	
**NOTE: If you receive a sync error "Unknown client" message in your sync callback, this means that the RHoSync server no longer knows about the client and a `Rhom::Rhom.database_fullclient_reset_and_logout` is recommended.  This error requires proper intervention in your app so you can handle the state before resetting the client.  For example, your sync notification could contain the following:**

	:::ruby
	if @params['error_message'].downcase == 'unknown client'
	  puts "Received unknown client, resetting!"
	  Rhom::Rhom.database_fullclient_reset_and_logout
	end

### `Rhom::Rhom.database_local_reset` 
Reset only local(non-sync-enabled) models.

	:::ruby
	Rhom::Rhom.database_local_reset

## Seeding the Database
If your application requires seeding some initial data, use the following method:

### `Rho::RhoUtils.load_offline_data(table_array, seed_prefix_directory)`

	:::ruby
	# table_array			 Array containing table names 
	#						 corresponding to pipe-delimited files.
	#
	# seed_prefix_directory  Relative path to directory containing 
	#						 a 'fixtures' directory of files.
	Rho::RhoUtils.load_offline_data(table_array, seed_prefix_directory)


For example, in the rhodes/spec/framework_spec, we use `load_offline_data` to seed the device database for each test:
	
	:::ruby
	Rho::RhoUtils.load_offline_data(
	  ['client_info','object_values'], 'spec'
	)

In this example, there is a 'spec/fixtures' directory which contains a `client_info.txt` and `object_values.txt` pipe-delimited files.  These files are structured as follows:

`client_info.txt`:
<pre>
client_id|last_sync_success
67320d31-e42e-4156-af91-5d9bd7175b08|
</pre>

`object_values.txt`:
<pre>
source_name|attrib|object|value
Case|status|4900dc4c072c|New|
Case|assigned_user_id|4900dc4c072c|48fce5e9fb16|
Case|work_log|4900dc4c072c||
Case|priority|4900dc4c072c|High|
...
</pre>

**NOTE: The column names are always the first line of the file.**

## Advanced Queries

### `find(*args)` (advanced conditions)
Rhom also supports advanced find `:conditions`.  Using advanced `:conditions`, rhom can optimize the query for the property bag table.

Let's say we have the following SQL fragment condition:

	:::ruby
	Product.find(
	 :all, 
	 :conditions => [ 
	   "LOWER(description) like ? or LOWER(title) like ?", 
	   query, 
	   query
	 ], 
	 :select => ['title','description'] 
	)

Using advanced `:conditions`, this becomes:

	:::ruby
	Product.find( 
	  :all, 
	  :conditions => { 
		{ 
		  :func => 'LOWER', 
		  :name => 'description', 
		  :op => 'LIKE'
		} => query, 
	    {
		  :func => 'LOWER', 
		  :name => 'title', 
		  :op => 'LIKE'
		} => query
	  }, 
	  :op => 'OR', 
	  :select => ['title','description']
	)

You can also use the 'IN' operator:

	:::ruby
	Product.find(
	  :all, 
	  :conditions => { 
	    {
		  :name => "image_uri", 
		  :op => "IN" 
		} => "'15704','15386'" 
	  } 
	)
	
	# or use array notation
	Product.find(
	  :all, 
	  :conditions => { 
	    {
		  :name => "image_uri", 
		  :op => "IN" 
		} => ["15704","15386"]
	  } 
	)

You can also groups `:conditions`:
	
	:::ruby
	cond1 = {
	  :conditions => { 
	    {
		  :func => 'UPPER', 
		  :name => 'name', 
		  :op => 'LIKE' 
		} => query, 
	    { 
		  :func => 'UPPER', 
		  :name => 'industry', 
		  :op => 'LIKE'
		} => query
	  }, 
	  :op => 'OR'
	}
	
	cond2 = {
	  :conditions => { 
	    {
		  :name => 'description', 
		  :op => 'LIKE'
	    } => 'Hello%'
	  }   
	}

	@accts = Account.find( 
	  :all, 
	  :conditions => [cond1, cond2], 
	  :op => 'AND', 
	  :select => ['name','industry']
	)
</source>